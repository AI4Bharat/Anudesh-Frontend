{"mappings":";;;;;;AEAO,SAAS;IACd,OACE,kBAAkB,UAClB,UAAU,cAAc,GAAG,KAC3B,UAAU,gBAAgB,GAAG;AAEjC;;;ACNO,SAAS,0CAAkB,EAAoB;IACpD,MAAM,QAAQ;IACd,MAAM,MAAM;IAEZ,IAAI,CAAC,IACH,OAAO;eAAE;aAAO;IAAI;IAGtB,IACE,OAAO,GAAG,cAAc,KAAK,YAC7B,OAAO,GAAG,YAAY,KAAK,UAE3B,OAAO;QAAE,OAAO,GAAG,cAAc;QAAE,KAAK,GAAG,YAAY;IAAC;IAG1D,OAAO;eAAE;aAAO;IAAI;AACtB;AAEO,SAAS,0CAAiB,IAAsB,EAAE,QAAgB;IACvE,IAAI;QACF,IAAI,KAAK,cAAc,EAAE;YACvB,KAAK,KAAK;YACV,KAAK,iBAAiB,CAAC,UAAU;QACnC,OACE,KAAK,KAAK;;AAGhB;;;;;;AC3BO,MAAM,4CAAc;IACzB,YAAY;IACZ,WAAW;IACX,SAAS;IACT,WAAW;AACb;;;ACQA,MAAM,uCAAiB;AACvB,MAAM,uCAAiB;AACvB,MAAM,kCAAY;AAElB,MAAM,8BAAoD;AAC1D,IAAI,wCAAkB;AAEtB,SAAS;IACP,MAAM,aAAa,aAAa,OAAO,CAAC;IACxC,OAAO,aAAa,KAAK,KAAK,CAAC,cAAc,CAAC;AAChD;AAEA,SAAS;IACP,aAAa,OAAO,CAAC,iCAAW,KAAK,SAAS,CAAC;AACjD;AAEA,MAAM,mDAA6B,CAAC;IAClC,IAAI,iBAAgC;IACpC,IAAI,aAAa;IAEjB,IAAK,MAAM,QAAQ,WACjB,IAAI,UAAU,CAAC,KAAK,CAAC,SAAS,GAAG,YAAY;QAC3C,aAAa,UAAU,CAAC,KAAK,CAAC,SAAS;QACvC,iBAAiB;IACnB;IAGF,OAAO;AACT;AAEO,MAAM,4CAA8B,OACzC,MACA,cACA,QACA;IAEA,MAAM,mCACJ,kBAAkB;IAClB,kCAAkC,YAClC,OAAO,MACR,GAAG,UAAU,CAAC;IACf,4BAA4B;IAC5B,mJAAmJ;IACnJ,iCAAiC;IACjC,wDAAwD;IAExD,IAAI,CAAC,2BAAK,CAAC,KAAK,EACd,2BAAK,CAAC,KAAK,GAAG,CAAC;IAGjB,IAAI,2BAAK,CAAC,KAAK,CAAC,KAAK,WAAW,GAAG,EAAE;QACnC,2BAAK,CAAC,KAAK,CAAC,KAAK,WAAW,GAAG,CAAC,SAAS,IAAI;QAC7C,OAAO,2BAAK,CAAC,KAAK,CAAC,KAAK,WAAW,GAAG,CAAC,WAAW;IACpD;IAEA,MAAM,iBAAiB;QACrB,QAAQ;QACR,SAAS;YACP,iBAAiB;QACnB;IACF;IAEA,IAAI;QACF,MAAM,MAAM,MAAM,MAChB,eACE,GAAG,KAAK,CAAC,EACP,SAAS,OAAO,SAAS,OACrB,MAAM,KAAK,OAAO,CAAC,KAAK,SACxB,mBAAmB,MAAM,OAAO,CAAC,KAAK,QAC1C,EACJ;QAEF,IAAI,OAAO,MAAM,IAAI,IAAI;QACzB,QAAQ,GAAG,CAAC,gBAAgB;QAC5B,IAAI,CAAC,aAAa,QAAQ,CAAC,aACzB,KAAK,MAAM,GAAG,KAAK,MAAM,CAAC,EAAE,CAAC,MAAM;QAErC,IAAI,QAAQ,KAAK,MAAM,CAAC,MAAM,GAAG,GAAG;YAClC,MAAM,QAAQ,kCACV;mBAAI,KAAK,MAAM;gBAAE;aAAK,GACtB,KAAK,MAAM;YAEf,IAAI,OAAO,IAAI,CAAC,2BAAK,CAAC,KAAK,EAAE,MAAM,IAAI,sCAAgB;gBACrD,MAAM,iBAAiB,iDAA2B,2BAAK,CAAC,KAAK;gBAC7D,IAAI,gBACF,OAAO,2BAAK,CAAC,KAAK,CAAC,eAAe;YAEtC;YAEA,2BAAK,CAAC,KAAK,CAAC,KAAK,WAAW,GAAG,GAAG;gBAChC,aAAa;gBACb,WAAW;YACb;YAEA,yCAAmB;YACnB,IAAI,yCAAmB,sCAAgB;gBACrC;gBACA,wCAAkB;YACpB;YAEA,OAAO;QACT,OAAO;YACL,IAAI,iCAAiC;gBACnC,MAAM,WAAW;oBAAC;iBAAK;gBACvB,OAAO;YACT;YACA,OAAO,EAAE;QACX;IACF,EAAE,OAAO,GAAG;QACV,cAAc;QACd,QAAQ,KAAK,CAAC,2CAA2C;QACzD,OAAO,EAAE;IACX;AACF;AAEA,OAAO,gBAAgB,CAAC,gBAAgB;;;AEhIjC,MAAM,4CAAW;AACjB,MAAM,4CAAc;;;ADEpB,MAAM,4CAA8B;IAGzC,IAAI,eAAe,OAAO,CAAC,6CACzB,OAAO,KAAK,KAAK,CACf,eAAe,OAAO,CAAC,+CAA+C;SAEnE;QACL,MAAM,SAAS,GAAG,CAAA,GAAA,yCAAO,EAAE,SAAS,CAAC;QACrC,MAAM,YAAY,IAAI;QACtB,UAAU,MAAM,CAAC,gBAAgB;QAEjC,MAAM,iBAAiB;YACrB,QAAQ;QACV;QACA,IAAI;YACF,MAAM,MAAM,MAAM,MAAM,QAAQ;YAChC,MAAM,OAAO,MAAM,IAAI,IAAI;YAC3B,eAAe,OAAO,CACpB,4CACA,KAAK,SAAS,CAAC;YAEjB,OAAO;QACT,EAAE,OAAO,GAAG;YACV,QAAQ,KAAK,CAAC,2CAA2C;YACzD,OAAO,EAAE;QACX;IACF;AACF;;;;ANnBA,MAAM,+BAAS;AACf,MAAM,iCAAW;AACjB,MAAM,iCAAW;AACjB,MAAM,kCAAY;AAClB,MAAM,mCAAa;AAEnB,MAAM,6CAAuB;AAC7B,MAAM,8CAAwB;AAUvB,MAAM,4CAAqB,CAAC,mBACjC,kBAAkB,CAAC,sBAAU,gBAAC;QAAO,GAAG,KAAK;cAC7C,OAAO,eACP,UAAU,YACV,UAAU,cACV,QAAQ,gBACR,YAAY,UACZ,MAAM,SACN,KAAK,aACL,SAAS,sBACT,qBAAqB,qBACrB,kBAAkB,CAAC,qBACnB,mBAAmB,CAAC,eACpB,aAAa,qCACb,mCAAmC,oCACnC,8BAA8B,kBAC9B,cAAc;IACZ,CAAA,GAAA,yCAAU,EAAE,SAAS;IACrB,CAAA,GAAA,yCAAU,EAAE,SAAS;IACrB,CAAA,GAAA,yCAAU,EAAE,UAAU;IACtB,CAAA,GAAA,yCAAU,EAAE,OAAO;CACpB,gCACD,+BAA+B,uCAC/B,kCAAkC,eAClC,UAAU,sBACV,iBAAiB,qBACjB,eAAe,CAAA,GAAA,yCAAU,WACzB,SAAS,eACT,YAAY,kBACZ,YAAY,IACZ,GAAG,MACqB;IAQxB,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAA,GAAA,eAAO,EAAE;IACjC,MAAM,CAAC,KAAK,OAAO,GAAG,CAAA,GAAA,eAAO,EAAE;IAC/B,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,eAAO,EAAU;IACnD,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,eAAO,EAAE;IAC7C,MAAM,CAAC,UAAU,YAAY,GAAG,CAAA,GAAA,eAAO,EAAE;IACzC,MAAM,WAAW,CAAA,GAAA,aAAK,EAAoB;IAC1C,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,eAAO,EAAE;QAAE,OAAO;QAAG,QAAQ;IAAE;IACnE,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,eAAO,EAAE;IAC3C,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,eAAO,EAAiB;IAC5D,MAAM,CAAC,SAAS,WAAW,GAAG,CAAA,GAAA,eAAO,EAAY,EAAE;IACnD,MAAM,CAAC,cAAc,gBAAgB,GAAG,CAAA,GAAA,eAAO,EAAa,EAAE;IAC9D,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,eAAO,EAAE;IAC3C,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,eAAO,EAAE;IAC7C,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAA,GAAA,eAAO,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG;IACtE,MAAM,CAAC,cAAc,gBAAgB,GAAG,CAAA,GAAA,eAAO,EAAE;IACjD,MAAM,CAAC,SAAS,WAAW,GAAG,CAAA,GAAA,eAAO,EAAE;IAEvC,MAAM,0BAA0B,CAAA,GAAA,cAAM,EACpC,IACE,mCACI,WAAW,KAAK,GAAG,8BACnB,MACN;QAAC;QAAY;QAA6B;KAAiC;IAG7E,MAAM,QAAQ;QACZ,sBAAsB;QACtB,aAAa;QACb,WAAW,EAAE;IACf;IAEA,MAAM,kBAAkB,CAAC;YAuChB;QAtCP,MAAM,gBAAgB;QACtB,oDAAoD;QACpD,oDAAoD;QACpD,MAAM,WACJ,cAAc,SAAS,CAAC,GAAG,cAC3B,OAAO,CAAC,MAAM,GACd,MACA,cAAc,SAAS,CAAC,WAAW,GAAG,cAAc,MAAM;QAE5D,IAAG,aAAa,MAAM,EAAC;YACrB,IAAI,cAAc,YAAY,CAAC,aAAa,MAAM,GAAC,EAAE;YACrD,IAAI,UAAkB;gBACpB,YAAY,YAAY,UAAU;gBAClC,SAAS,YAAY,OAAO;gBAC5B,OAAO,OAAO,CAAC,MAAM;gBACrB,YAAY,IAAI,OAAO,WAAW;gBAClC,UAAU;YAAI;YAChB,gBAAgB;mBAAI;gBAAc;aAAQ;YAC1C,aAAa,YAAU;QACzB;QAEA,iEAAiE;QACjE,+BAA+B;QAC/B,WAAW;YACT,CAAA,GAAA,yCAAe,EACb,oEAAoE;YACpE,SAAS,OAAO,EAChB,aAAa,OAAO,CAAC,MAAM,CAAC,MAAM,GAAG;QAEzC,GAAG;QAEH,0CAA0C;QAC1C,MAAM,IAAI;YACR,QAAQ;gBAAE,OAAO;YAAS;QAC5B;QACA,aAAa;QACb,YAAY,SAAS;QACrB;QACA,QAAO,oBAAA,SAAS,OAAO,cAAhB,wCAAA,kBAAkB,KAAK;IAChC;IAEA,MAAM,oBAAoB,OAAO,UAAkB;QACjD,IAAI,CAAC,yBACH;QAEF,4BAA4B;QAC5B,uJAAuJ;QAEvJ,qDAAqD;QACrD,qBAAqB;QACrB,kBAAkB;QAElB,MAAM,OAAO,MAAM,CAAA,GAAA,yCAA0B,EAAE,UAAU,cAAc,QAAQ;6CAE7E,AADA,cAAc;YACd;kBACA;QACF;QACA,WAAW,iBAAA,kBAAA,OAAQ,EAAE;QACrB,IAAI,UAAkB;YACZ,YAAY;YACZ,SAAS;YACT,OAAO;YACP,YAAY,IAAI,OAAO,WAAW;YAClC,UAAU;QAAI;QAExB,IAAG,SAAQ;YACT,WAAW;YACX,gBAAgB;gBAAC;aAAQ;QAC3B,OACE,gBAAgB;eAAI;YAAc;SAAQ;IAE9C;IAEA,MAAM,sBAAsB,OAAO;QACjC,MAAM,WAAW,MAAM,CAAA,GAAA,yCAA0B;QACjD,MAAM,UAAU,qBAAA,+BAAA,SAAU,IAAI,CAAC,CAAC,IAAM,EAAE,QAAQ,KAAK;YAEnD;QADF,OAAO;YACL,CAAA,qBAAA,oBAAA,8BAAA,QAAS,SAAS,cAAlB,gCAAA,qBAAsB;YACtB,oBAAA,8BAAA,QAAS,UAAU;YACnB,oBAAA,8BAAA,QAAS,YAAY;SACtB;IACH;IAEA,MAAM,eAAe,CAAC;QACpB,MAAM,QAAQ,EAAE,aAAa,CAAC,KAAK;QAEnC,IAAG,aAAa,KAAK;YACnB,IAAG,MAAM,MAAM,IAAI,GACnB,gBAAgB,MAAM,MAAM,GAAC;iBAE7B,gBAAgB;;QAIlB,IAAI,aAAa,GAAE;YACjB,MAAM,YAAY;gBAAC,QAAQ;gBAAM,eAAe;gBAAY,QAAQ;gBAAO,UAAU,aAAa,OAAO,CAAC,aAAa,YAAY,aAAa,OAAO,CAAC,YAAY;gBAAe,YAAY;gBAAM,SAAQ;YAAY;YACzN,gBAAgB,EAAE;YAClB,cAAc;YACd,QAAQ,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG;YAC7C,gBAAgB,MAAM,MAAM,GAAC;YAC7B,aAAa;YACb,WAAW;YACX,MAAM,yEAAyE;gBAC7E,QAAQ;gBACR,MAAM,KAAK,SAAS,CAAC;gBACrB,SAAS;oBACP,gBAAgB;gBAClB;YACF,GACC,IAAI,CAAC,OAAO;gBACX,IAAI,CAAC,IAAI,EAAE,EAAG,MAAM,MAAM,IAAI,IAAI;YACpC,GACC,KAAK,CAAC,CAAC;gBACN,QAAQ,GAAG,CAAC,SAAS;YACvB;QACF;QAEA,0CAA0C;QAC1C,YAAY,SAAS;QACrB,aAAa;QAEb,IAAI,CAAC,yBACH;QAGF,sCAAsC;QACtC,MAAM,QAAQ,CAAA,GAAA,yCAAgB,EAAE,EAAE,MAAM,EAAsB,GAAG;QACjE,MAAM,QAAQ,SAAS,OAAO;QAE9B,IAAI,CAAC,OAAO;QAEZ,MAAM,WAAW,CAAA,GAAA,oBAAkB,EAAE,OAAO;QAE5C,4DAA4D;QAC5D,aAAa;QACb,MAAM,mBACJ,MAAM,WAAW,CAAC,KAAK,QAAQ,KAAK,MAAM,WAAW,CAAC,MAAM,QAAQ,KAChE,MAAM,WAAW,CAAC,MAAM,QAAQ,KAChC,MAAM,WAAW,CAAC,KAAK,QAAQ;QAErC,uDAAuD;QACvD,0CAA0C;QAC1C,6DAA6D;QAC7D,eAAe;QACf,cAAc,mBAAmB;QACjC,YAAY,QAAQ;QAEpB,8CAA8C;QAC9C,MAAM,cAAc,MAAM,KAAK,CAAC,mBAAmB,GAAG;QACtD,IAAI,eAAe,SAAS;YAC1B,wCAAwC;YAC1C,IAAG,aAAa,KAAK;gBACnB,IAAG,MAAM,MAAM,IAAI,GACnB,kBAAkB,aAAa,MAAM,MAAM,CAAC,MAAM,MAAM,GAAC,GAAG,MAAM,MAAM;qBAExE,kBAAkB,aAAa,MAAM,MAAM,CAAC,GAAG,MAAM,MAAM;mBAG3D,kBAAkB,aAAa,MAAM,MAAM,CAAC,cAAc,MAAM,MAAM;YAGtE,MAAM,OAAO,MAAM,qBAAqB;YAExC,oDAAoD;YAEpD,0DAA0D;YAC1D,0BAA0B;YAC1B,MAAM,OAAO,KAAK,GAAG,CACnB,SAAS,IAAI,EACb,KAAK,KAAK,GAAG,8CAAwB;YAGvC,0DAA0D;YAC1D,8BAA8B;YAC9B,MAAM,MAAM,KAAK,GAAG,CAAC,SAAS,GAAG,GAAG,4CAAsB,KAAK,MAAM;YAErE,OAAO;YACP,QAAQ;QACV,OACE;IAEJ;IAEA,MAAM,gBAAgB,CAAC;QACrB,MAAM,gBAAgB,QAAQ,MAAM,GAAG;QAEvC,IAAI;YACF,IAAI,YAAY,QAAQ,CAAC,MAAM,GAAG,GAAG;gBACnC,MAAM,cAAc;gBACpB,gBAAgB;YAClB,OACE,OAAQ,MAAM,GAAG;gBACf,KAAK;oBACH,MAAM,cAAc;oBACpB;oBACA;gBACF,KAAK;oBACH,MAAM,cAAc;oBACpB,aAAa,AAAC,CAAA,QAAQ,MAAM,GAAG,YAAY,CAAA,IAAK,QAAQ,MAAM;oBAC9D;gBACF,KAAK;oBACH,MAAM,cAAc;oBACpB,aAAa,AAAC,CAAA,YAAY,CAAA,IAAK,QAAQ,MAAM;oBAC7C;gBACF,KAAK;oBACH,MAAM,cAAc;oBACpB,aAAa,AAAC,CAAA,QAAQ,MAAM,GAAG,YAAY,CAAA,IAAK,QAAQ,MAAM;oBAC9D;gBACF,KAAK;oBACH,MAAM,cAAc;oBACpB,aAAa,AAAC,CAAA,YAAY,CAAA,IAAK,QAAQ,MAAM;oBAC7C;gBACF;oBACE,aAAa,UAAU;oBACvB;YACJ;eAGF,aAAa,UAAU;IAE3B;IAEA,MAAM,aAAa,CACjB;QAEA,IAAI,CAAC,CAAA,GAAA,yCAAa;YAChB,IAAI,gCAAgC,OAAO,CAAC,UAAU,EACpD,gBAAgB;iBAEhB;;QAGJ,UAAU,OAAO;IACnB;IAEA,MAAM,eAAe;QACnB,+CAA+C;QAC/C,mCAAmC;QACnC,MAAM,QAAQ,OAAO,UAAU;QAC/B,MAAM,SAAS,OAAO,WAAW;QACjC,cAAc;mBAAE;oBAAO;QAAO;IAChC;IAEA,CAAA,GAAA,gBAAQ,EAAE;QACR,OAAO,gBAAgB,CAAC,UAAU;QAClC,MAAM,QAAQ,OAAO,UAAU;QAC/B,MAAM,SAAS,OAAO,WAAW;QACjC,cAAc;mBAAE;oBAAO;QAAO;QAE9B,OAAO;YACL,OAAO,mBAAmB,CAAC,UAAU;QACvC;IACF,GAAG,EAAE;IAEL,CAAA,GAAA,gBAAQ,EAAE;QACR,oBAAoB,MAAM,IAAI,CAAC,CAAC,CAAC,WAAW,YAAY,aAAa;YACnE,aAAa;YACb,6CAA6C;YAC7C,IAAI,YAAY;gBACd,IAAI,CAAC,SAAS,cAAc,CAAC,CAAC,KAAK,EAAE,YAAY,GAAG;oBAClD,MAAM,OAAO,SAAS,aAAa,CAAC;oBACpC,KAAK,EAAE,GAAG,CAAC,KAAK,EAAE,YAAY;oBAC9B,KAAK,IAAI,GAAG,CAAC,wCAAwC,EAAE,YAAY;oBACnE,KAAK,GAAG,GAAG;oBACX,SAAS,IAAI,CAAC,WAAW,CAAC;gBAC5B;gBACA,cAAc,GAAG,WAAW,EAAE,EAAE,yBAAA,0BAAA,eAAgB,cAAc;YAChE,OACE,cAAc;QAElB;IACF,GAAG;QAAC;KAAK;IAET,MAAM,oBAAoB;YAkBxB;QAjBA,MAAM,SAAS,SAAS,OAAO;QAC/B,IAAI,CAAC,QAAQ;QAEb,MAAM,SAAS,SAAS,aAAa,CAAC;QACtC,OAAO,SAAS,GAAG;QACnB,OAAO,KAAK,CAAC,QAAQ,GAAG;QACxB,OAAO,KAAK,CAAC,OAAO,GAAG;QACvB,OAAO,KAAK,CAAC,MAAM,GAAG;QACtB,OAAO,KAAK,CAAC,MAAM,GAAG;QACtB,OAAO,KAAK,CAAC,UAAU,GAAG;QAC1B,OAAO,KAAK,CAAC,YAAY,GAAG;QAC5B,OAAO,KAAK,CAAC,SAAS,GAAG;QACzB,OAAO,KAAK,CAAC,MAAM,GAAG;QACtB,OAAO,KAAK,CAAC,KAAK,GAAG;QAErB,MAAM,UAAU,SAAS,aAAa,CAAC;QACvC,QAAQ,KAAK,CAAC,QAAQ,GAAG;SACzB,qBAAA,OAAO,UAAU,cAAjB,yCAAA,mBAAmB,YAAY,CAAC,SAAS;QACzC,QAAQ,WAAW,CAAC;QACpB,QAAQ,WAAW,CAAC;QAEpB,IAAI,gBAAsC;QAC1C,IAAI,cAA0B,EAAE;QAChC,IAAI,cAAc;QAElB,OAAO,OAAO,GAAG;YACf,IAAI,CAAC,UAAU,YAAY,EAAE;gBAC3B,MAAM;gBACN;YACF;YAEA,IAAI,eAAe,eAAe;gBAChC,cAAc,IAAI;gBAClB,cAAc;gBACd,OAAO,SAAS,GAAG;YACrB,OAAO;gBACL,MAAM,SAAS,MAAM,UAAU,YAAY,CAAC,YAAY,CAAC;oBAAE,OAAO;gBAAK;gBACvE,gBAAgB,IAAI,cAAc;gBAElC,cAAc,EAAE;gBAEhB,cAAc,eAAe,GAAG,CAAC;oBAC/B,YAAY,IAAI,CAAC,MAAM,IAAI;gBAC7B;gBAEA,cAAc,MAAM,GAAG;oBACrB,MAAM,YAAY,IAAI,KAAK,aAAa;wBAAE,MAAM;oBAAa;oBAC7D,MAAM,cAAc,MAAM,gBAAgB;oBAE1C,MAAM,aAAa,MAAM,qBAAqB,WAAW,MAAM;wBAEjD;oBAAd,MAAM,QAAQ,CAAA,yBAAA,OAAO,cAAc,cAArB,oCAAA,yBAAyB;wBAC3B;oBAAZ,MAAM,MAAM,CAAA,uBAAA,OAAO,YAAY,cAAnB,kCAAA,uBAAuB;oBACnC,MAAM,OAAO,OAAO,KAAK;oBACzB,OAAO,KAAK,GAAG,KAAK,KAAK,CAAC,GAAG,SAAS,aAAa,KAAK,KAAK,CAAC;gBAChE;gBAEA,cAAc,KAAK;gBACnB,cAAc;gBACd,OAAO,SAAS,GAAG;YACrB;QACF;IACF;IAEA,eAAe,gBAAgB,IAAU;QACvC,MAAM,cAAc,MAAM,KAAK,WAAW;QAC1C,MAAM,aAAa,IAAI,WAAW;QAClC,IAAI,SAAS;QACb,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,IACrC,UAAU,OAAO,YAAY,CAAC,UAAU,CAAC,EAAE;QAE7C,OAAO,KAAK;IACd;IAEA,eAAe,qBAAqB,MAAc,EAAE,IAAY,EAAE,WAAmB;QACnF,IAAI;YACF,MAAM,WAAW,MAAM,MAAM,QAAQ;gBACnC,QAAQ;gBACR,SAAS;oBAAE,gBAAgB;gBAAmB;gBAC9C,MAAM,KAAK,SAAS,CAAC;oBAAE,aAAa;0BAAa;gBAAK;YACxD;YAEA,MAAM,SAAS,MAAM,SAAS,IAAI;YAClC,OAAO,OAAO,UAAU,IAAI;QAC9B,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC,4BAA4B;YAC1C,OAAO;QACT;IACF;IAEA,CAAA,GAAA,gBAAQ,EAAE;QACR,IAAG,WACD;IAEJ,GAAG;QAAC;KAAU;IAGd,qBACE,iBAAC;QACC,sDAAsD;QACtD,0BAA0B;QAC1B,OAAO;YACL,GAAG,eAAe;YAClB,UAAU;QACZ;QACA,WAAW;;YAEV,gBAAgB;gBACf,UAAU;gBACV,WAAW;gBACX,QAAQ;gBACR,KAAK;gBACL,OAAO;gBACP,eAAe;gBACf,MAAM;gBACN,OAAO;oBACL,WAAW;oBACX,GAAI,cAAc;wBAAE,YAAY;oBAAW,CAAC;gBAC9C;gBACA,GAAG,IAAI;YACT;YACC,2BAA2B,QAAQ,MAAM,GAAG,mBAC3C,gBAAC;gBACC,OAAO;oBACL,gBAAiB;oBACjB,iBAAkB;oBAClB,QAAS;oBACT,WAAY;oBACZ,SAAS,iBAAiB,SAAS;oBACnC,UAAU;oBACV,WAAW;oBACX,SAAS;oBACT,WAAW;oBACX,QAAQ;oBACR,MAAM,GAAG,OAAO,QAAQ,EAAE,CAAC;oBAC3B,KAAK,GAAG,MAAM,QAAQ,EAAE,CAAC;oBACzB,UAAU;oBACV,OAAO;oBACP,GAAI,cAAc;wBAAE,YAAY;oBAAW,CAAC;gBAC9C;gBACA,eAAY;gBACZ,MAAM;0BAML,MAAM,IAAI,CAAC,IAAI,IAAI,UAAU,GAAG,CAAC,CAAC,MAAM,sBACvC,gBAAC;wBACC,OAAO,UAAU,YAAY;4BAAE,QAAQ;4BAAU,SAAS;4BAAO,UAAU;4BAAQ,iBAAiB;4BAAW,OAAM;wBAAM,IAAI;4BAAE,QAAQ;4BAAU,SAAS;4BAAO,UAAU;4BAAQ,iBAAiB;wBAAM;wBAC5M,cAAc;4BACZ,aAAa;wBACf;wBACA,SAAS,IAAM,gBAAgB;kCAG9B;uBAFI;;;;AASnB","sources":["src/index.tsx","src/util/index.ts","src/util/touch-util.ts","src/util/caret-util.ts","src/constants/TriggerKeys.ts","src/util/suggestions-util.ts","src/util/getTransliterationLanguages.ts","src/constants/Urls.ts"],"sourcesContent":["import * as React from \"react\";\nimport { useEffect, useRef, useState, useMemo } from \"react\";\nimport { setCaretPosition, getInputSelection, isTouchEnabled } from \"./util\";\nimport getCaretCoordinates from \"textarea-caret\";\nimport { IndicTransliterateProps } from \"./interfaces/Props\";\nimport { Language } from \"./types/Language\";\nimport { LangObject } from \"./types/LangObject\";\nimport { TriggerKeys } from \"./constants/TriggerKeys\";\nimport { getTransliterateSuggestions } from \"./util/suggestions-util\";\nimport { getTransliterationLanguages } from \"./util/getTransliterationLanguages\";\nimport { BASE_URL_TL } from \"./constants/Urls\";\n\nconst KEY_UP = \"ArrowUp\";\nconst KEY_DOWN = \"ArrowDown\";\nconst KEY_LEFT = \"ArrowLeft\";\nconst KEY_RIGHT = \"ArrowRight\";\nconst KEY_ESCAPE = \"Escape\";\n\nconst OPTION_LIST_Y_OFFSET = 10;\nconst OPTION_LIST_MIN_WIDTH = 100;\n\ndeclare var MediaRecorder: {\n  prototype: MediaRecorder;\n  new(stream: MediaStream): MediaRecorder;\n};\ninterface BlobEvent extends Event {\n  data: Blob;\n}\n\nexport const IndicTransliterate = ({\n  renderComponent = (props) => <input {...props} />,\n  lang = \"hi\",\n  offsetX = 0,\n  offsetY = 10,\n  onChange,\n  onChangeText,\n  onBlur,\n  value,\n  onKeyDown,\n  containerClassName = \"\",\n  containerStyles = {},\n  activeItemStyles = {},\n  maxOptions = 5,\n  hideSuggestionBoxOnMobileDevices = false,\n  hideSuggestionBoxBreakpoint = 450,\n  triggerKeys = [\n    TriggerKeys.KEY_SPACE,\n    TriggerKeys.KEY_ENTER,\n    TriggerKeys.KEY_RETURN,\n    TriggerKeys.KEY_TAB,\n  ],\n  insertCurrentSelectionOnBlur = true,\n  showCurrentWordAsLastSuggestion = true,\n  enabled = true,\n  horizontalView = false,\n  customApiURL = BASE_URL_TL,\n  apiKey = \"\",\n  enableASR = false,\n  asrApiUrl = \"\",\n  ...rest\n}: IndicTransliterateProps): JSX.Element => {\n  interface LogJson {\n    keystrokes: any;\n    results: any;\n    opted: any;\n    created_at: any;\n    language: any;\n  }\n  const [left, setLeft] = useState(0);\n  const [top, setTop] = useState(0);\n  const [selection, setSelection] = useState<number>(0);\n  const [matchStart, setMatchStart] = useState(-1);\n  const [matchEnd, setMatchEnd] = useState(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [windowSize, setWindowSize] = useState({ width: 0, height: 0 });\n  const [direction, setDirection] = useState(\"ltr\");\n  const [googleFont, setGoogleFont] = useState<string | null>(null);\n  const [options, setOptions] = useState<string[]>([]);\n  const [logJsonArray, setLogJsonArray] = useState<LogJson[]>([]);\n  const [numSpaces, setNumSpaces] = useState(0);\n  const [parentUuid, setParentUuid] = useState(\"0\");\n  const [uuid, setUuid] = useState(Math.random().toString(36).substr(2, 9));\n  const [subStrLength, setSubStrLength] = useState(0);\n  const [restart, setRestart] = useState(true);\n\n  const shouldRenderSuggestions = useMemo(\n    () =>\n      hideSuggestionBoxOnMobileDevices\n        ? windowSize.width > hideSuggestionBoxBreakpoint\n        : true,\n    [windowSize, hideSuggestionBoxBreakpoint, hideSuggestionBoxOnMobileDevices],\n  );\n\n  const reset = () => {\n    // reset the component\n    setSelection(0);\n    setOptions([]);\n  };\n\n  const handleSelection = (index: number) => {\n    const currentString = value;\n    // create a new string with the currently typed word\n    // replaced with the word in transliterated language\n    const newValue =\n      currentString.substring(0, matchStart) +\n      options[index] +\n      \" \" +\n      currentString.substring(matchEnd + 1, currentString.length);\n\n    if(logJsonArray.length){\n      let lastLogJson = logJsonArray[logJsonArray.length-1];\n      let logJson:LogJson = {\n        keystrokes: lastLogJson.keystrokes,\n        results: lastLogJson.results,\n        opted: options[index],\n        created_at: new Date().toISOString(),\n        language: lang};\n      setLogJsonArray([...logJsonArray, logJson]);\n      setNumSpaces(numSpaces+1);\n    }\n\n    // set the position of the caret (cursor) one character after the\n    // the position of the new word\n    setTimeout(() => {\n      setCaretPosition(\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        inputRef.current!,\n        matchStart + options[index].length + 1\n      );\n    }, 1);\n\n    // bubble up event to the parent component\n    const e = {\n      target: { value: newValue },\n    } as unknown as React.FormEvent<HTMLInputElement>;\n    onChangeText(newValue);\n    onChange && onChange(e);\n    reset();\n    return inputRef.current?.focus();\n  };\n\n  const renderSuggestions = async (lastWord: string, wholeText: string) => {\n    if (!shouldRenderSuggestions) {\n      return;\n    }\n    // fetch suggestion from api\n    // const url = `https://www.google.com/inputtools/request?ime=transliteration_en_${lang}&num=5&cp=0&cs=0&ie=utf-8&oe=utf-8&app=jsapi&text=${lastWord}`;\n\n    // const numOptions = showCurrentWordAsLastSuggestion\n    //   ? maxOptions - 1\n    //   : maxOptions;\n\n    const data = await getTransliterateSuggestions(lastWord, customApiURL, apiKey, {\n      // numOptions,\n      showCurrentWordAsLastSuggestion,\n      lang,\n    });\n    setOptions(data ?? []);\n    let logJson:LogJson = {\n              keystrokes: wholeText,\n              results: data,\n              opted: \"\",\n              created_at: new Date().toISOString(),\n              language: lang}\n\n    if(restart){\n      setRestart(false);\n      setLogJsonArray([logJson]);\n    }else{\n      setLogJsonArray([...logJsonArray, logJson]);\n    }\n  };\n\n  const getDirectionAndFont = async (lang: Language) => {\n    const langList = await getTransliterationLanguages();\n    const langObj = langList?.find((l) => l.LangCode === lang) as LangObject;\n    return [\n      langObj?.Direction ?? \"ltr\",\n      langObj?.GoogleFont,\n      langObj?.FallbackFont,\n    ];\n  };\n\n  const handleChange = (e: React.FormEvent<HTMLInputElement>) => {\n    const value = e.currentTarget.value;\n\n    if(numSpaces == 0 || restart){\n      if(value.length >= 4){\n      setSubStrLength(value.length-4);\n      }else{\n      setSubStrLength(0);\n      }\n    } \n\n    if (numSpaces >= 5){\n      const finalJson = {\"uuid\": uuid, \"parent_uuid\": parentUuid, \"word\": value, \"source\": localStorage.getItem('source') != undefined ? localStorage.getItem('source') : \"node-module\", \"language\": lang, \"steps\":logJsonArray};\n      setLogJsonArray([]);\n      setParentUuid(uuid);\n      setUuid(Math.random().toString(36).substr(2, 9));\n      setSubStrLength(value.length-2);\n      setNumSpaces(0);\n      setRestart(true);\n      fetch(\"https://backend.shoonya.ai4bharat.org/logs/transliteration_selection/\", {\n        method: \"POST\",\n        body: JSON.stringify(finalJson),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n      })\n      .then(async (res) => {\n        if (!res.ok) {throw await res.json()};\n      })\n      .catch((err) => {\n        console.log(\"error\", err);\n      });\n    }\n\n    // bubble up event to the parent component\n    onChange && onChange(e);\n    onChangeText(value);\n\n    if (!shouldRenderSuggestions) {\n      return;\n    }\n\n    // get the current index of the cursor\n    const caret = getInputSelection(e.target as HTMLInputElement).end;\n    const input = inputRef.current;\n\n    if (!input) return;\n\n    const caretPos = getCaretCoordinates(input, caret);\n\n    // search for the last occurence of the space character from\n    // the cursor\n    const indexOfLastSpace =\n      value.lastIndexOf(\" \", caret - 1) < value.lastIndexOf(\"\\n\", caret - 1)\n        ? value.lastIndexOf(\"\\n\", caret - 1)\n        : value.lastIndexOf(\" \", caret - 1);\n\n    // first character of the currently being typed word is\n    // one character after the space character\n    // index of last character is one before the current position\n    // of the caret\n    setMatchStart(indexOfLastSpace + 1);\n    setMatchEnd(caret - 1);\n\n    // currentWord is the word that is being typed\n    const currentWord = value.slice(indexOfLastSpace + 1, caret);\n    if (currentWord && enabled) {\n      // make an api call to fetch suggestions\n    if(numSpaces == 0 || restart){\n      if(value.length >= 4){\n      renderSuggestions(currentWord, value.substr(value.length-4, value.length));\n      }else{\n      renderSuggestions(currentWord, value.substr(0, value.length));\n      }\n    }else{\n      renderSuggestions(currentWord, value.substr(subStrLength, value.length));\n    }\n\n      const rect = input.getBoundingClientRect();\n\n      // calculate new left and top of the suggestion list\n\n      // minimum of the caret position in the text input and the\n      // width of the text input\n      const left = Math.min(\n        caretPos.left,\n        rect.width - OPTION_LIST_MIN_WIDTH / 2,\n      );\n\n      // minimum of the caret position from the top of the input\n      // and the height of the input\n      const top = Math.min(caretPos.top + OPTION_LIST_Y_OFFSET, rect.height);\n\n      setTop(top);\n      setLeft(left);\n    } else {\n      reset();\n    }\n  };\n\n  const handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {\n    const helperVisible = options.length > 0;\n\n    if (helperVisible) {\n      if (triggerKeys.includes(event.key)) {\n        event.preventDefault();\n        handleSelection(selection);\n      } else {\n        switch (event.key) {\n          case KEY_ESCAPE:\n            event.preventDefault();\n            reset();\n            break;\n          case KEY_UP:\n            event.preventDefault();\n            setSelection((options.length + selection - 1) % options.length);\n            break;\n          case KEY_DOWN:\n            event.preventDefault();\n            setSelection((selection + 1) % options.length);\n            break;\n          case KEY_LEFT:\n            event.preventDefault();\n            setSelection((options.length + selection - 1) % options.length);\n            break;\n          case KEY_RIGHT:\n            event.preventDefault();\n            setSelection((selection + 1) % options.length);\n            break;\n          default:\n            onKeyDown && onKeyDown(event);\n            break;\n        }\n      }\n    } else {\n      onKeyDown && onKeyDown(event);\n    }\n  };\n\n  const handleBlur = (\n    event: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement>,\n  ) => {\n    if (!isTouchEnabled()) {\n      if (insertCurrentSelectionOnBlur && options[selection]) {\n        handleSelection(selection);\n      } else {\n        reset();\n      }\n    }\n    onBlur && onBlur(event);\n  };\n\n  const handleResize = () => {\n    // TODO implement the resize function to resize\n    // the helper on screen size change\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    setWindowSize({ width, height });\n  };\n\n  useEffect(() => {\n    window.addEventListener(\"resize\", handleResize);\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    setWindowSize({ width, height });\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n    };\n  }, []);\n\n  useEffect(() => {\n    getDirectionAndFont(lang).then(([direction, googleFont, fallbackFont]) => {\n      setDirection(direction);\n      // import google font if not already imported\n      if (googleFont) {\n        if (!document.getElementById(`font-${googleFont}`)) {\n          const link = document.createElement(\"link\");\n          link.id = `font-${googleFont}`;\n          link.href = `https://fonts.googleapis.com/css?family=${googleFont}`;\n          link.rel = \"stylesheet\";\n          document.head.appendChild(link);\n        }\n        setGoogleFont(`${googleFont}, ${fallbackFont ?? \"sans-serif\"}`);\n      } else {\n        setGoogleFont(null);\n      }\n    });\n  }, [lang]);\n\n  const enableVoiceTyping = () => {  \n    const target = inputRef.current;\n    if (!target) return;\n  \n    const micBtn = document.createElement(\"button\");\n    micBtn.innerHTML = \"🎤\";\n    micBtn.style.position = \"absolute\";\n    micBtn.style.padding = \"5px\";\n    micBtn.style.border = \"none\";\n    micBtn.style.cursor = \"pointer\";\n    micBtn.style.background = \"#fff\";\n    micBtn.style.borderRadius = \"50%\";\n    micBtn.style.boxShadow = \"0 0 6px rgba(0,0,0,0.2)\";\n    micBtn.style.bottom = \"5px\";\n    micBtn.style.right = \"5px\";\n  \n    const wrapper = document.createElement(\"div\");\n    wrapper.style.position = \"relative\";\n    target.parentNode?.insertBefore(wrapper, target);\n    wrapper.appendChild(target);\n    wrapper.appendChild(micBtn);\n  \n    let mediaRecorder: MediaRecorder | null = null;\n    let audioChunks: BlobPart[] = [];\n    let isRecording = false;\n  \n    micBtn.onclick = async () => {\n      if (!navigator.mediaDevices) {\n        alert(\"Browser doesn't support audio recording.\");\n        return;\n      }\n  \n      if (isRecording && mediaRecorder) {\n        mediaRecorder.stop();\n        isRecording = false;\n        micBtn.innerHTML = \"🎤\";\n      } else {\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n        mediaRecorder = new MediaRecorder(stream);\n  \n        audioChunks = [];\n  \n        mediaRecorder.ondataavailable = (event: BlobEvent) => {\n          audioChunks.push(event.data);\n        };\n  \n        mediaRecorder.onstop = async () => {\n          const audioBlob = new Blob(audioChunks, { type: \"audio/webm\" });\n          const base64Audio = await blobToBase64Raw(audioBlob);\n  \n          const transcript = await transcribeWithDhruva(asrApiUrl, lang, base64Audio);\n  \n          const start = target.selectionStart ?? 0;\n          const end = target.selectionEnd ?? 0;\n          const text = target.value;\n          target.value = text.slice(0, start) + transcript + text.slice(end);\n        };\n  \n        mediaRecorder.start();\n        isRecording = true;\n        micBtn.innerHTML = \"⏹️\"; \n      }\n    };\n  }\n  \n  async function blobToBase64Raw(blob: Blob): Promise<string> {\n    const arrayBuffer = await blob.arrayBuffer();\n    const uint8Array = new Uint8Array(arrayBuffer);\n    let binary = \"\";\n    for (let i = 0; i < uint8Array.length; i++) {\n      binary += String.fromCharCode(uint8Array[i]);\n    }\n    return btoa(binary);\n  }\n  \n  async function transcribeWithDhruva(apiURL: string, lang: string, base64Audio: string): Promise<string> {\n    try {\n      const response = await fetch(apiURL, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ audioBase64: base64Audio, lang }),\n      });\n  \n      const result = await response.json();\n      return result.transcript || \"\";\n    } catch (err) {\n      console.error(\"Transcription API error:\", err);\n      return \"\";\n    }\n  }\n\n  useEffect(() => {\n    if(enableASR){\n      enableVoiceTyping();\n    }\n  }, [enableASR]);\n  \n\n  return (\n    <div\n      // position relative is required to show the component\n      // in the correct position\n      style={{\n        ...containerStyles,\n        position: \"relative\",\n      }}\n      className={containerClassName}\n    >\n      {renderComponent({\n        onChange: handleChange,\n        onKeyDown: handleKeyDown,\n        onBlur: handleBlur,\n        ref: inputRef,\n        value: value,\n        \"data-testid\": \"rt-input-component\",\n        lang: lang,\n        style: {\n          direction: direction,\n          ...(googleFont && { fontFamily: googleFont }),\n        },\n        ...rest,\n      })}\n      {shouldRenderSuggestions && options.length > 0 && (\n        <ul\n          style={{\n            backgroundClip : \"padding-box\",\n            backgroundColor : \"#fff\",\n            border : \"1px solid rgba(0, 0, 0, 0.15)\",\n            boxShadow : \"0 6px 12px rgba(0, 0, 0, 0.175)\",\n            display: horizontalView ? \"flex\" : \"block\",\n            fontSize: \"14px\",\n            listStyle: \"none\",\n            padding: \"1px\",\n            textAlign: \"center\",\n            zIndex: 20000,\n            left: `${left + offsetX}px`,\n            top: `${top + offsetY}px`,\n            position: \"absolute\",\n            width: \"auto\",\n            ...(googleFont && { fontFamily: googleFont }),\n          }}\n          data-testid=\"rt-suggestions-list\"\n          lang={lang}\n        >\n          {/*\n           * convert to set and back to prevent duplicate list items\n           * that might happen while using backspace\n           */}\n          {Array.from(new Set(options)).map((item, index) => (\n            <li\n              style={index === selection ? { cursor: \"pointer\",padding: \"10px\",minWidth: \"100px\",backgroundColor: \"#65c3d7\", color:\"#fff\"} : { cursor: \"pointer\",padding: \"10px\",minWidth: \"100px\",backgroundColor: \"#fff\"} }\n              onMouseEnter={() => {\n                setSelection(index);\n              }}\n              onClick={() => handleSelection(index)}\n              key={item}\n            >\n              {item}\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n};\n\nexport type { IndicTransliterateProps, Language };\nexport { TriggerKeys, getTransliterateSuggestions };\nexport { getTransliterationLanguages };\n","import { isTouchEnabled } from \"./touch-util\";\nimport { getInputSelection, setCaretPosition } from \"./caret-util\";\n\nexport { isTouchEnabled, getInputSelection, setCaretPosition };\n","export function isTouchEnabled() {\n  return (\n    \"ontouchstart\" in window ||\n    navigator.maxTouchPoints > 0 ||\n    navigator.msMaxTouchPoints > 0\n  );\n}\n","export function getInputSelection(el: HTMLInputElement) {\n  const start = 0;\n  const end = 0;\n\n  if (!el) {\n    return { start, end };\n  }\n\n  if (\n    typeof el.selectionStart === \"number\" &&\n    typeof el.selectionEnd === \"number\"\n  ) {\n    return { start: el.selectionStart, end: el.selectionEnd };\n  }\n\n  return { start, end };\n}\n\nexport function setCaretPosition(elem: HTMLInputElement, caretPos: number) {\n  if (elem) {\n    if (elem.selectionStart) {\n      elem.focus();\n      elem.setSelectionRange(caretPos, caretPos);\n    } else {\n      elem.focus();\n    }\n  }\n}\n","export const TriggerKeys = {\n  KEY_RETURN: \"Enter\",\n  KEY_ENTER: \"Enter\",\n  KEY_TAB: \"Tab\",\n  KEY_SPACE: \" \",\n};\n","import { Language } from \"../types/Language\";\n\ntype Config = {\n  // numOptions?: number;\n  showCurrentWordAsLastSuggestion?: boolean;\n  lang?: Language;\n};\n\ntype CacheEntry = {\n  suggestions: string[];\n  frequency: number;\n};\n\nconst MAX_CACHE_SIZE = 10000;\nconst SAVE_THRESHOLD = 20;\nconst CACHE_KEY = 'transliterationCache';\n\nconst cache: Record<string, Record<string, CacheEntry>> = loadCacheFromLocalStorage();\nlet newEntriesCount = 0;\n\nfunction loadCacheFromLocalStorage(): Record<string, Record<string, CacheEntry>> {\n  const cachedData = localStorage.getItem(CACHE_KEY);\n  return cachedData ? JSON.parse(cachedData) : {};\n}\n\nfunction saveCacheToLocalStorage() {\n  localStorage.setItem(CACHE_KEY, JSON.stringify(cache));\n}\n\nconst getWordWithLowestFrequency = (dictionary: Record<string, CacheEntry>): string | null => {\n  let lowestFreqWord: string | null = null;\n  let lowestFreq = Infinity;\n\n  for (const word in dictionary) {\n    if (dictionary[word].frequency < lowestFreq) {\n      lowestFreq = dictionary[word].frequency;\n      lowestFreqWord = word;\n    }\n  }\n\n  return lowestFreqWord;\n};\n\nexport const getTransliterateSuggestions = async (\n  word: string,\n  customApiURL: string,\n  apiKey: string,\n  config?: Config,\n): Promise<string[] | undefined> => {\n  const {\n    // numOptions = 5,\n    showCurrentWordAsLastSuggestion = true,\n    lang = \"hi\",\n  } = config || {};\n  // fetch suggestion from api\n  // const url = `https://www.google.com/inputtools/request?ime=transliteration_en_${lang}&num=5&cp=0&cs=0&ie=utf-8&oe=utf-8&app=jsapi&text=${word}`;\n  // let myHeaders = new Headers();\n  // myHeaders.append(\"Content-Type\", \"application/json\");\n\n  if (!cache[lang]) {\n    cache[lang] = {};\n  }\n\n  if (cache[lang][word.toLowerCase()]) {\n    cache[lang][word.toLowerCase()].frequency += 1;\n    return cache[lang][word.toLowerCase()].suggestions;\n  }\n\n  const requestOptions = {\n    method: \"GET\",\n    headers: {\n      \"Authorization\": apiKey,\n    },\n  };\n\n  try {\n    const res = await fetch(\n      customApiURL +\n        `${lang}/${\n          word === \".\" || word === \"..\"\n            ? \" \" + word.replace(\".\", \"%2E\")\n            : encodeURIComponent(word).replace(\".\", \"%2E\")\n        }`,\n      requestOptions,\n    );\n    let data = await res.json();\n    console.log(\"library data\", data);\n    if (!customApiURL.includes(\"xlit-api\")) {\n      data.result = data.output[0].target;\n    }\n    if (data && data.result.length > 0) {\n      const found = showCurrentWordAsLastSuggestion\n        ? [...data.result, word]\n        : data.result;\n\n      if (Object.keys(cache[lang]).length >= MAX_CACHE_SIZE) {\n        const lowestFreqWord = getWordWithLowestFrequency(cache[lang]);\n        if (lowestFreqWord) {\n          delete cache[lang][lowestFreqWord];\n        }\n      }\n\n      cache[lang][word.toLowerCase()] = {\n        suggestions: found,\n        frequency: 1,\n      };\n\n      newEntriesCount += 1;\n      if (newEntriesCount >= SAVE_THRESHOLD) {\n        saveCacheToLocalStorage();\n        newEntriesCount = 0;\n      }\n\n      return found;\n    } else {\n      if (showCurrentWordAsLastSuggestion) {\n        const fallback = [word];\n        return fallback;\n      }\n      return [];\n    }\n  } catch (e) {\n    // catch error\n    console.error(\"There was an error with transliteration\", e);\n    return [];\n  }\n};\n\nwindow.addEventListener('beforeunload', saveCacheToLocalStorage);","import { LangObject } from \"../types/LangObject\";\nimport { BASE_URL } from \"../constants/Urls\";\n\nexport const getTransliterationLanguages = async (): Promise<\n  LangObject[] | undefined\n> => {\n  if (sessionStorage.getItem(\"indic_transliterate__supported_languages\")) {\n    return JSON.parse(\n      sessionStorage.getItem(\"indic_transliterate__supported_languages\") || \"\",\n    );\n  } else {\n    const apiURL = `${BASE_URL}languages`;\n    const myHeaders = new Headers();\n    myHeaders.append(\"Content-Type\", \"application/json\");\n\n    const requestOptions = {\n      method: \"GET\",\n    };\n    try {\n      const res = await fetch(apiURL, requestOptions);\n      const data = await res.json();\n      sessionStorage.setItem(\n        \"indic_transliterate__supported_languages\",\n        JSON.stringify(data),\n      );\n      return data;\n    } catch (e) {\n      console.error(\"There was an error with transliteration\", e);\n      return [];\n    }\n  }\n};\n","export const BASE_URL = \"https://xlit-api.ai4bharat.org/\";\nexport const BASE_URL_TL = \"https://xlit-api.ai4bharat.org/tl/\";\n"],"names":[],"version":3,"file":"index.modern.js.map","sourceRoot":"../"}